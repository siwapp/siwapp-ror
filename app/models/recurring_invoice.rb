class RecurringInvoice < Common

  # make this object a publisher
  include Wisper::Publisher

  # Relations
  has_many :invoices

  # Validation
  validates :series, presence: true
  validates :name, presence: true
  validates :starting_date, presence: true, if: :status?
  validates :period, :period_type, presence: true, if: :status?
  validate :valid_date_range

  # callbacks
  after_initialize :set_default_status

  PERIOD_TYPES = [
    ["Daily", "days"],
    ["Monthly", "months"],
    ["Yearly", "years"]
  ].freeze

  # Status
  INACTIVE = 0
  ACTIVE = 1

  STATUS = {inactive: INACTIVE, active: ACTIVE}

  def to_s
    "#{name}"
  end

  # returns all recurring_invoices with specified status
  scope :with_status, -> (status) {where status: status}

  def get_status
    if status
      STATUS[status]
    else
      # For nil case
      STATUS[:inactive]
    end
  end

  def next_invoice_date
    self.invoices.length > 0 ? self.invoices.last.issue_date + period.send(period_type) : starting_date
  end

  def generate_pending_invoices
    if !status?
      return
    end

    # how many invoices are generated by now
    occurrences = Invoice.belonging_to(id).count
    next_date = next_invoice_date()

    generated_invoices = []

    while next_date <= [Date.current, finishing_date.blank? ? Date.current + 1 : finishing_date].min and
        (max_occurrences.nil? or occurrences < max_occurrences) do
      inv = self.becomes(Invoice).deep_clone include: { items: :taxes}, except: [:period, :period_type, :starting_date, :finishing_date, :max_occurrences]

      inv.recurring_invoice_id = self.id
      inv.status = 'Open'
      inv.issue_date = next_date
      inv.due_date = Date.current + days_to_due.days if days_to_due

      inv.items.each do |item|
        item.description.sub! "$(issue_date)", inv.issue_date.strftime('%Y-%m-%d')
        item.description.sub! "$(issue_date - period)", (inv.issue_date - period.send(period_type)).strftime('%Y-%m-%d')
        item.description.sub! "$(issue_date + period)", (inv.issue_date + period.send(period_type)).strftime('%Y-%m-%d')
       end

      broadcast(:invoice_generation, inv)
      next_date += period.send period_type
      occurrences += 1
      generated_invoices.append inv
      inv.save # de momento.
    end



  
      # if inv.save
      #   inv.send_email if self.sent_by_email  # If recurring is set to send emails
      # end

    save
    generated_invoices
  end

  def self.with_pending_invoices
    # candidates to have pending invoices
    candidates = with_status(1).where("period is not null").
      where(period_type: ['days', 'months', 'years'])
    pendings = []
    candidates.each do |actual|

      # get the finishing date from either max_occurrences or finishing_date
      ending_date = Date.new 2999
      if actual.max_occurrences?
        if Invoice.belonging_to(actual.id).count >= actual.max_occurrences
          next
        end
        ending_date = actual.starting_date +
          (actual.period * actual.max_occurrences).send(actual.period_type)
      end
      if actual.finishing_date? and actual.finishing_date < ending_date
        ending_date = actual.finishing_date
      end

      # get the next invoice issuing date
      next_date = actual.invoices.length > 0 ? \
          actual.invoices.last.created_at + actual.period.send(actual.period_type) \
          : actual.starting_date

      # is it within range?
      if next_date > Date.current or !next_date.in? (actual.starting_date...ending_date)
        next
      end

      pendings.append actual
    end
  end

  def test
    broadcast(:invoice_generation, Invoice.first)
  end


  private

  def valid_date_range
    return if starting_date.blank? || finishing_date.blank?

    if starting_date > finishing_date
      errors.add(:finishing_time, "Finishing Date must be after Starting Date")
    end
  end

  def set_default_status
    # default status for new records is "active"
    if status.nil?
      self.status = 1
    end
  end

end
